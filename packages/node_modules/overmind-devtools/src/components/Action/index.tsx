import { createElement, FunctionComponent, Fragment } from 'react'
import { useOvermind } from '../../overmind'
import * as styles from './styles'
import ActionOperator from '../ActionOperator'
import { getOperatorId, nameToColor } from '../../overmind/utils'
import { Operator } from '../../overmind/types'

type OperatorsByPath = {
  path: string
  operators: Operator[]
  children: OperatorsByPath[]
  value: any
}

// TODO: Remove flush by action id?
const Action: FunctionComponent = () => {
  const { state } = useOvermind()

  const operators = Object.keys(state.currentAction.operators)
    .sort()
    .map((operatorId) => state.currentAction.operators[operatorId])
  const operatorsByPath = operators.reduce(
    (aggr, operator): OperatorsByPath[] => {
      let currentValue = state.currentAction.value
      const traversePath = operator.path.slice()
      traversePath.unshift('')
      traversePath.reduce((children, key, index) => {
        let child = children.reduce(
          (hit, child) => (child.path === key ? child : hit),
          null
        )

        if (index === traversePath.length - 1) {
          if (child && !child.children.length) {
            child.operators.push(operator)
          } else {
            child = {
              path: key,
              operators: [operator],
              children: [],
              value: child
                ? child.operators[child.operators.length - 1].result
                : currentValue,
            }
            children.push(child)
          }
        } else {
          currentValue = child.value
        }

        return child.children
      }, aggr)

      return aggr
    },
    []
  )
  function renderOperators(operators: OperatorsByPath[]) {
    return operators.map((operatorsByPath, index) => {
      return (
        <div
          key={operatorsByPath.path + index}
          className={styles.operatorChildren}
        >
          {operatorsByPath.path ? (
            <div
              className={styles.path}
              style={{
                backgroundColor: nameToColor(operatorsByPath.path),
              }}
            >
              {operatorsByPath.path}
            </div>
          ) : null}
          <div className={styles.pathOperators}>
            {operatorsByPath.operators.map((operator, index) => {
              const flushReference =
                state.currentApp.flushByOperatorId[getOperatorId(operator)]
              const flush =
                flushReference &&
                state.currentApp.flushes[flushReference.flushId]

              return (
                <Fragment key={getOperatorId(operator)}>
                  <ActionOperator
                    operator={operator}
                    flush={flush}
                    value={
                      index === 0
                        ? operatorsByPath.value
                        : operatorsByPath.operators[index - 1].result
                    }
                  />
                </Fragment>
              )
            })}
            {operatorsByPath.children.length
              ? renderOperators(operatorsByPath.children)
              : null}
          </div>
        </div>
      )
    })
  }

  console.log(operatorsByPath)

  return (
    <div className={styles.wrapper}>
      {renderOperators(operatorsByPath)}
      {state.currentAction.isIntercepted ? (
        <div className={styles.breakStyle}>break</div>
      ) : null}
    </div>
  )
}

export default Action
