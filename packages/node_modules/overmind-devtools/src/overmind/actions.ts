import { Action, pipe, OnInitialize, Operator } from 'overmind'
import {
  Message,
  Tab,
  AppMessageType,
  ExecutionType,
  ActionsListItemType,
  Component,
} from './types'
import {
  forkEachMessage,
  ensureCurrentApp,
  addFlushAndRunMutations,
  updateComponent,
  addComponent,
  removeComponent,
  updateDerived,
  updateFlushWithDerived,
  addAction,
  addOperator,
  updateOperator,
  updateAction,
  addMutations,
  updateEffect,
  setPortExists,
  isPortExistsMessage,
  getMessages,
  addStateAndActions,
  ensureApp,
  addClientMessages,
  updateOperatorAsync,
  runGetterMutation,
  updateState,
} from './operators'
import { isValidJson } from './utils'

export const onInitialize: OnInitialize = async ({ state, effects }, app) => {
  const port = await effects.storage.get<string>('currentPort')
  if (port) {
    state.port = port
  }
  effects.connector.onMessage(app.actions.onMessage)
  effects.connector.connect(state.port)
}

const handleClientMessage: Operator<Message, any> = pipe(
  ensureCurrentApp,
  ensureApp,
  addClientMessages,
  getMessages,
  forkEachMessage({
    [AppMessageType.PORT_EXISTS]: setPortExists,
    [ExecutionType.INIT]: addStateAndActions,
    [ExecutionType.RE_INIT]: addStateAndActions,
    [ExecutionType.FLUSH]: addFlushAndRunMutations,
    [ExecutionType.DERIVED]: updateDerived,
    [ExecutionType.MUTATIONS]: addMutations,
    [ExecutionType.EFFECT]: updateEffect,
    [ExecutionType.STATE]: updateState,
    [ExecutionType.COMPONENT_ADD]: addComponent,
    [ExecutionType.COMPONENT_UPDATE]: updateComponent,
    [ExecutionType.COMPONENT_REMOVE]: removeComponent,
    [ExecutionType.DERIVED_DIRTY]: updateFlushWithDerived,
    [ExecutionType.ACTION_START]: addAction,
    [ExecutionType.OPERATOR_START]: addOperator,
    [ExecutionType.OPERATOR_END]: updateOperator,
    [ExecutionType.ACTION_END]: updateAction,
    [ExecutionType.OPERATOR_ASYNC]: updateOperatorAsync,
    [ExecutionType.GETTER]: runGetterMutation,
  })
)

export const onMessage: Operator<Message> = pipe(
  isPortExistsMessage({
    true: setPortExists,
    false: handleClientMessage,
  })
)

export const setError: Action<string> = ({ state }, error) =>
  (state.error = error)

export const changeNewPortValue: Action<string> = ({ state }, port) =>
  (state.newPortValue = String(Number(port)))

export const addConnection: Action = ({ state, effects }) => {
  state.error = null
  state.isConnecting = true
  state.port = state.newPortValue
  state.newPortValue = ''
  effects.connector.connect(state.port)
}

export const changeTab: Action<Tab> = ({ state }, tab) =>
  (state.currentTab = tab)

export const toggleExpandState: Action<string[]> = ({ state }, path) => {
  const pathString = path.join('.')

  if (state.currentApp.expandedStatePaths.indexOf(pathString) >= 0) {
    state.currentApp.expandedStatePaths.splice(
      state.currentApp.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.currentApp.expandedStatePaths = state.currentApp.expandedStatePaths.concat(
      pathString
    )
  }
}

export const selectAction: Action<string> = ({ state }, actionId) => {
  for (let index in state.currentApp.actionsList) {
    const item = state.currentApp.actionsList[index]
    if (
      item.type === ActionsListItemType.GROUP &&
      item.id === actionId &&
      state.currentApp.currentActionId === actionId
    ) {
      item.isCollapsed = !item.isCollapsed
      break
    }
  }
  state.currentApp.currentActionId = actionId
}

export const toggleGroupedComponent: Action<string> = ({ state }, name) => {
  const index = state.currentApp.expandedComponents.indexOf(name)

  if (index === -1) {
    state.currentApp.expandedComponents.push(name)
  } else {
    state.currentApp.expandedComponents.splice(index, 1)
  }
}

export const selectApp: Action<string> = ({ state }, appName) => {
  state.currentAppName = appName
  state.showApps = false
}

export const toggleShowApps: Action = ({ state }) =>
  (state.showApps = !state.showApps)

export const toggleCollapsedComponent: Action<Component> = (_, component) =>
  (component.isCollapsed = !component.isCollapsed)

export const toggleQueryingAction: Action = ({ state }) => {
  state.currentApp.isQueryingAction = !state.currentApp.isQueryingAction
}

export const changeActionQuery: Action<string> = ({ state }, query) => {
  state.currentApp.actionQuery = query

  const hit = state.currentApp.actionPaths.find((path) =>
    path.startsWith(query)
  )

  if (query.length && hit) {
    state.currentApp.actionQuerySuggestion = hit
  } else {
    state.currentApp.actionQuerySuggestion = ''
  }
}

export const selectQueryAction: Action<string> = ({ state, effects }, path) => {
  state.currentApp.selectedActionQuery = path
  state.currentApp.isQueryingAction = false
  state.currentApp.actionQueryPayload = ''
  effects.storage.set(`${state.currentApp.name}.selectedActionQuery`, path)
}

export const submitQueryAction: Action = ({ state, effects }) => {
  if (!state.currentApp.actionQuerySuggestion) {
    return
  }

  state.currentApp.selectedActionQuery = state.currentApp.actionQuerySuggestion
  state.currentApp.isQueryingAction = false
  state.currentApp.actionQueryPayload = ''

  effects.storage.set(
    `${state.currentApp.name}.selectedActionQuery`,
    state.currentApp.selectedActionQuery
  )
}

export const executeAction: Action = ({ state, effects }) => {
  const payload = state.currentApp.actionQueryPayload

  if (payload && !isValidJson(payload)) {
    return
  }

  effects.connector.sendMessage(state.currentApp.name, 'executeAction', {
    name: state.currentApp.selectedActionQuery,
    payload: state.currentApp.actionQueryPayload,
  })
}

export const setActionQueryPayload: Action<string> = ({ state }, payload) => {
  state.currentApp.actionQueryPayload = payload
}

export const setState: Action<string[]> = ({ state }, path) => {
  state.currentApp.selectedStatePath = path.join('.')
}

export const undoSettingState: Action = ({ state }) => {
  state.currentApp.selectedStatePath = null
}

export const submitState: Action<string> = ({ state, effects }, newState) => {
  const path = state.currentApp.selectedStatePath.split('.')

  effects.connector.sendMessage(state.currentApp.name, 'mutation', {
    path,
    value: newState,
  })

  state.currentApp.selectedStatePath = null
}
