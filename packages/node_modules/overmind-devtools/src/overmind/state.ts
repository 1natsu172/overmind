import { Derive } from 'overmind'
import {
  Action,
  App,
  Apps,
  Component,
  Flush,
  GroupedComponents,
  Tab,
} from './types'

type State = {
  isConnecting: boolean
  error: string
  port: string
  apps: Apps
  currentAppName: string
  newPortValue: string
  currentTab: Tab
  showApps: boolean
  expandedStatePaths: string[]
  expandedComponents: string[]
  currentAction: Derive<State, Action>
  currentApp: App
  componentsMounted: Derive<State, Component[]>
  componentsUpdateCount: Derive<State, number>
  componentsStatePathCount: Derive<State, number>
  flushes: Derive<State, Flush[]>
  flushesMutationsCount: Derive<State, number>
  flushesStatePathCount: Derive<State, number>
  groupedComponents: Derive<State, GroupedComponents>
}

const state: State = {
  isConnecting: true,
  error: null,
  showApps: false,
  currentAppName: null,
  port: '3031',
  apps: {},
  newPortValue: '',
  currentTab: Tab.State,
  expandedStatePaths: [''],
  expandedComponents: [],
  get currentApp() {
    const state: State = this

    return state.apps[state.currentAppName]
  },
  componentsMounted: (state) =>
    Object.keys(state.currentApp.components).reduce(
      (aggr, key) => {
        if (state.currentApp.components[key].isMounted) {
          return aggr.concat(state.currentApp.components[key])
        }

        return aggr
      },
      [] as Component[]
    ),
  componentsUpdateCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.updateCount,
      0
    ),
  componentsStatePathCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.paths.length,
      0
    ),
  flushes: (state) =>
    Object.keys(state.currentApp.flushes)
      .sort(
        (idA, idB) =>
          state.currentApp.flushes[idB].flushId -
          state.currentApp.flushes[idA].flushId
      )
      .map((id) => state.currentApp.flushes[id]),
  flushesMutationsCount: (state) =>
    state.flushes.reduce((aggr, flush) => aggr + flush.mutations.length, 0),
  flushesStatePathCount: (state) =>
    state.flushes.reduce((aggr, flush) => {
      return flush.mutations.reduce(
        (aggr, mutation) =>
          aggr.includes(mutation.path) ? aggr : aggr.concat(mutation.path),
        aggr
      )
    }, []).length,
  currentAction: (state) =>
    state.currentApp.actions[state.currentApp.currentActionId],
  groupedComponents(state) {
    const components = state.componentsMounted

    return components.reduce(
      (aggr, component) => {
        if (aggr[component.name]) {
          aggr[component.name].components.push(component)
        } else {
          aggr[component.name] = {
            name: component.name,
            components: [component],
            isCollapsed: !state.expandedComponents.includes(component.name),
          }
        }

        return aggr
      },
      {} as GroupedComponents
    )
  },
}

export default state
