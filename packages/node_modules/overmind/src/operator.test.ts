import { createOperator, createMutationOperator } from './operator'
import { Overmind, IConfig, IOperator, pipe, map, mutate } from './'

describe('OPERATOR', () => {
  test('should be able to create an operator', () => {
    expect.assertions(1)
    function toUpperCase(): Operator<string> {
      return createOperator('toUpperCase', '', (err, _, value, next) => {
        if (err) next(err, value)
        else next(null, value.toUpperCase())
      })
    }

    const test: Operator = pipe(
      map(({ state }) => state.foo),
      toUpperCase(),
      mutate(({ state }, val) => {
        state.foo = val
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('BAR')
    })
  })
  test('should be able to create an ERROR operator', () => {
    let operatorsRun = 0

    expect.assertions(2)
    function catchError<Input>(
      operation: (error: Error) => void
    ): Operator<Input> {
      return createOperator(
        'catchError',
        operation.name,
        (err, _, value, next) => {
          if (err) next(null, operation(err))
          else next(null, value)
        }
      )
    }

    const test: Operator = pipe(
      mutate(() => {
        throw new Error('wut')
      }),
      mutate(({ state }, val) => {
        operatorsRun++
      }),
      catchError((err) => {
        expect(err.message).toBe('wut')
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(operatorsRun).toBe(0)
    })
  })
  test('should be able to create an operator managing paths', () => {
    expect.assertions(1)
    function whenBananaOrApple(paths: {
      banana: Operator<string>
      apple: Operator<string>
    }): Operator<string> {
      return createOperator('whenBananaOrApple', '', (err, _, value, next) => {
        if (err) next(err, value)
        else
          next(null, value, {
            path: {
              name: value,
              operator: paths[value],
            },
          })
      })
    }

    const test: Operator<string> = whenBananaOrApple({
      banana: mutate(({ state }) => {
        state.foo = 'banana'
      }),
      apple: mutate(({ state }) => {
        state.foo = 'apple'
      }),
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('banana').then(() => {
      expect(overmind.state.foo).toBe('banana')
    })
  })
  test('should be able to create an operator that can mutate', () => {
    expect.assertions(1)
    function changeState<Input>(
      operation: (state: Config['state']) => void
    ): Operator<Input> {
      return createMutationOperator<Config>(
        'changeState',
        operation.name,
        (err, context, value, next) => {
          if (err) next(err, value)
          else {
            operation(context.state)
            next(null, value)
          }
        }
      )
    }

    const test: Operator = changeState((state) => {
      state.foo = 'hihihi'
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('hihihi')
    })
  })
})
