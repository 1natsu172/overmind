import { createOperator, createMutationOperator } from './operator'
import { Overmind, IConfig, IOperator, IAction, pipe, map, action } from './'
import { IS_PROXY, PATH } from 'proxy-state-tree'

describe('OPERATOR', () => {
  test('should be able to create an operator', () => {
    expect.assertions(1)
    function toUpperCase(): Operator<string> {
      return createOperator('toUpperCase', '', (err, _, value, next) => {
        if (err) next(err, value)
        else next(null, value.toUpperCase())
      })
    }

    const test: Operator = pipe(
      map(({ state }) => state.foo),
      toUpperCase(),
      action(({ state }, val) => {
        state.foo = val
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('BAR')
    })
  })
  test('should be able to create an ERROR operator', () => {
    let operatorsRun = 0

    expect.assertions(2)
    function catchError<Input>(
      operation: (error: Error) => void
    ): Operator<Input> {
      return createOperator(
        'catchError',
        operation.name,
        (err, _, value, next) => {
          if (err) next(null, operation(err))
          else next(null, value)
        }
      )
    }

    const test: Operator = pipe(
      action(() => {
        throw new Error('wut')
      }),
      action(({ state }, val) => {
        operatorsRun++
      }),
      catchError((err) => {
        expect(err.message).toBe('wut')
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(operatorsRun).toBe(0)
    })
  })
  test('should be able to create an operator managing paths', () => {
    expect.assertions(1)
    function whenBananaOrApple(paths: {
      banana: Operator<string>
      apple: Operator<string>
    }): Operator<string> {
      return createOperator('whenBananaOrApple', '', (err, _, value, next) => {
        if (err) next(err, value)
        else
          next(null, value, {
            path: {
              name: value,
              operator: paths[value],
            },
          })
      })
    }

    const test: Operator<string> = whenBananaOrApple({
      banana: action(({ state }) => {
        state.foo = 'banana'
      }),
      apple: action(({ state }) => {
        state.foo = 'apple'
      }),
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('banana').then(() => {
      expect(overmind.state.foo).toBe('banana')
    })
  })
  test('should be able to create an operator that can mutate', () => {
    expect.assertions(1)
    function changeState<Input>(
      operation: (state: Config['state']) => void
    ): Operator<Input> {
      return createMutationOperator<Config>(
        'changeState',
        operation.name,
        (err, context, value, next) => {
          if (err) next(err, value)
          else {
            operation(context.state)
            next(null, value)
          }
        }
      )
    }

    const test: Operator = changeState((state) => {
      state.foo = 'hihihi'
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('hihihi')
    })
  })
  test('should be able to create an operator that can track mutations', (done) => {
    function waitForMutation(
      operation: (state: Config['state']) => void
    ): Operator {
      return createOperator<Config>(
        'waitForMutation',
        operation.name,
        (err, context, value, next, final, execution) => {
          if (err) next(err, value)
          else {
            const tree = execution.getTrackStateTree()
            tree.track(() => {
              next(null, value)
            })
            operation(tree.state)
          }
        }
      )
    }

    const waitForFoo: Operator = waitForMutation((state) => {
      state.foo
    })

    const test: Action = pipe(waitForFoo)

    const mutateFoo: Action = ({ state }) => {
      state.foo = 'hihihi'
    }

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
        mutateFoo,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    overmind.actions.test().then(done)

    // Trigger mutation with an action.
    overmind.actions.mutateFoo()
  })
  test('should be able to create an operator that can track flushes', (done) => {
    function waitForFlush(
      operation: (state: Config['state']) => any
    ): Operator {
      return createOperator<Config>(
        'waitForFlush',
        operation.name,
        (err, context, value, next, final, execution) => {
          if (err) next(err, value)
          else {
            const observedValue = operation(context.state)
            const observerdPath = observedValue[IS_PROXY]
              ? observedValue[PATH]
              : null
            execution.onFlush((_, paths) => {
              paths.forEach((path) => {
                if (path.startsWith(observerdPath)) next(null, value)
              })
            })
          }
        }
      )
    }

    const waitForFoo: Operator = waitForFlush((state) => state.foo)

    const test: Action = pipe(waitForFoo)

    const mutateBar: Action = ({ state }) => {
      state.foo.bar = 'hihihi'
    }

    const state = {
      foo: {
        bar: 'baz',
      },
    }

    const config = {
      state,
      actions: {
        test,
        mutateBar,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    overmind.actions.test().then(done)

    // Trigger mutation with an action.
    overmind.actions.mutateBar()
  })
})
