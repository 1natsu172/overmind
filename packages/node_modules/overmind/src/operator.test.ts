import {
  createOperator,
  createMutationOperator,
  createMutationListenerOperator,
} from './operator'
import {
  Overmind,
  IConfig,
  IOperator,
  IAction,
  pipe,
  map,
  action,
  EventType,
} from './'

describe('OPERATOR', () => {
  test('should be able to create an operator', () => {
    expect.assertions(1)
    function toUpperCase(): Operator<string> {
      return createOperator('toUpperCase', '', (err, _, value, next) => {
        if (err) next(err, value)
        else next(null, value.toUpperCase())
      })
    }

    const test: Operator = pipe(
      map(({ state }) => state.foo),
      toUpperCase(),
      action(({ state }, val) => {
        state.foo = val
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('BAR')
    })
  })
  test('should be able to create an ERROR operator', () => {
    let operatorsRun = 0

    expect.assertions(2)
    function catchError<Input>(
      operation: (error: Error) => void
    ): Operator<Input> {
      return createOperator(
        'catchError',
        operation.name,
        (err, _, value, next) => {
          if (err) next(null, operation(err))
          else next(null, value)
        }
      )
    }

    const test: Operator = pipe(
      action(() => {
        throw new Error('wut')
      }),
      action(({ state }, val) => {
        operatorsRun++
      }),
      catchError((err) => {
        expect(err.message).toBe('wut')
      })
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(operatorsRun).toBe(0)
    })
  })
  test('should be able to create an operator managing paths', () => {
    expect.assertions(1)
    function whenBananaOrApple(paths: {
      banana: Operator<string>
      apple: Operator<string>
    }): Operator<string> {
      return createOperator('whenBananaOrApple', '', (err, _, value, next) => {
        if (err) next(err, value)
        else
          next(null, value, {
            name: value,
            operator: paths[value],
          })
      })
    }

    const test: Operator<string> = whenBananaOrApple({
      banana: action(({ state }) => {
        state.foo = 'banana'
      }),
      apple: action(({ state }) => {
        state.foo = 'apple'
      }),
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('banana').then(() => {
      expect(overmind.state.foo).toBe('banana')
    })
  })
  test('should be able to create an operator that can mutate', () => {
    expect.assertions(1)
    function changeState<Input>(
      operation: (state: Config['state']) => void
    ): Operator<Input> {
      return createMutationOperator<Config>(
        'changeState',
        operation.name,
        (err, context, value, next) => {
          if (err) next(err, value)
          else {
            operation(context.state)
            next(null, value)
          }
        }
      )
    }

    const test: Operator = changeState((state) => {
      state.foo = 'hihihi'
    })

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test().then(() => {
      expect(overmind.state.foo).toBe('hihihi')
    })
  })
  test('should be able to create an operator that can track', (done) => {
    function waitForMutation(
      operation: (state: Config['state']) => void
    ): Operator {
      return createMutationListenerOperator<Config>(
        'waitForMutation',
        operation.name,
        (err, context, value, next, final, track) => {
          if (err) next(err, value)
          else {
            operation(context.state)
            track(() => {
              next(null, value)
            })
          }
        }
      )
    }

    const waitForFoo: Operator = waitForMutation((state) => {
      state.foo
    })

    const test: Action = pipe(waitForFoo)

    const mutateFoo: Action = ({ state }) => {
      state.foo = 'hihihi'
    }

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
        mutateFoo,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    overmind.actions.test().then(done)

    // Trigger mutation with an action.
    overmind.actions.mutateFoo()

    // Trigger mutation with a mutation tree and flush it.
    const tree = overmind as any
    const mutationTree = tree.proxyStateTree.getMutationTree()
    tree.state.foo = 'hihihi'
    tree.flush()
  })
})
