import {
  IConfig,
  IConfiguration,
  IDerive,
  filter,
  map,
  mutate,
  parallel,
  pipe,
} from '../'

export interface Statechart<C extends IConfiguration, S extends string> {
  initial: S
  states: {
    [N in S]: {
      entry?: keyof C['actions']
      exit?: keyof C['actions']
      chart?: Statechart<C, any> | Array<Statechart<C, any>>
      on?: {
        [N in keyof C['actions']]?:
          | S
          | {
              target: S
              condition: (state: C['state']) => boolean
            }
          | null
      }
    }
  }
}

function getActionTransitions(
  key: string,
  chart: Statechart<any, any> | Statechart<any, any>[],
  state: { states: Array<(string | number)[]> }
) {
  const transitions: (string | boolean)[] = []
  state.states.forEach((statePath) => {
    const path = statePath.slice()

    while (path.length) {
      const target = getStateTarget(chart, path)

      if (target.entry === key) {
        transitions.push('entry')
        return
      }
      if (target.exit === key) {
        transitions.push('exit')
        return
      }
      if (target.on && target.on[key] === null) {
        transitions.push(true)
        return
      }
      if (target.on && typeof target.on[key] === 'string') {
        // If we have already transition to this path it means
        // we are moving away from multiple paths (parallel)
        if (transitions.includes(target.on[key])) {
          return
        }
        transitions.push(target.on[key])
        return
      }
      if (target.on && target.on[key] && target.on[key].condition(state)) {
        transitions.push(target.on[key].target)
        return
      }

      path.pop()
    }

    transitions.push(false)
  })

  return transitions
}

// We check if any transitions returned are not "false",
// which means any entry, exit or state transition should occur on
// any of existing state paths active
function getCanTransitionActions(actions, chart, state) {
  return Object.keys(actions || {}).reduce((aggr, key) => {
    aggr[key] = getActionTransitions(key, chart, state).some(
      (transition) => transition !== false
    )

    return aggr
  }, {})
}

function getInitialStates(chart, paths: Array<(string | number)[]> = [[]]) {
  if (Array.isArray(chart)) {
    const initialPath = paths[paths.length - 1].slice()
    chart.forEach((chartItem, index) => {
      if (index > 0) {
        paths.push(initialPath.slice())
      }
      paths[paths.length - 1].push(index)
      getInitialStates(chartItem, paths)
    })
  } else {
    paths[paths.length - 1].push(chart.initial)
    if (chart.states[chart.initial].chart) {
      getInitialStates(chart.states[chart.initial].chart, paths)
    }
  }

  return paths
}

function createNewStatePath(
  currentStates: Array<string[]>,
  transitionStates: string[],
  chart: Statechart<any, any> | Statechart<any, any>[],
  index: number
) {
  const newStatePath: (string | number)[] = []
  let x = 0
  let transitionState = transitionStates.shift()

  // Keep existing state before transition
  while (!transitionState && transitionStates.length) {
    newStatePath.push(currentStates[index][x])
    transitionState = transitionStates.shift()
  }

  if (!transitionState) {
    return currentStates[index]
  }

  // Add the new transition
  newStatePath.push(transitionState)

  const stateTarget = getStateTarget(chart, newStatePath)

  // If we have more nested state, go grab the initial states
  if (stateTarget.chart) {
    return newStatePath.concat(getInitialStates(stateTarget.chart)[index])
  }

  return newStatePath
}

function getTarget(source, path) {
  return path.reduce((aggr, key) => aggr[key], source)
}

// We iterate the state chart to find a state target. It
// uses parallel number indexes and string target to find
// it
function getStateTarget(chart, path) {
  return path.reduce(
    (aggr, key, index) => {
      if (typeof key === 'number') {
        return aggr[key]
      }

      if (index === path.length - 1) {
        return aggr.states[key]
      }

      return aggr.states[key].chart
    },

    chart
  )
}

export function statechart<C extends IConfiguration>(
  config: C,
  chart: Statechart<C, string> | Array<Statechart<C, string>>
): IConfig<{
  onInitialize: C['onInitialize']
  state: C['state'] & {
    states: Array<(string | number)[]>
    actions: { [N in keyof C['actions']]: boolean }
    matches: IDerive<any, any, (...args: Array<string | string[]>) => boolean>
  }
  actions: C['actions']
  effects: C['effects']
}> & {
  onInitialize: C['onInitialize']
} {
  let currentInstance
  const actions = config.actions || {}
  const state = config.state || {}

  if (config.state && (config.state as any).states) {
    throw new Error(
      `Overmind statecharts: You have already defined the state "states" in your configuration. Statecharts needs this, please rename it`
    )
  }

  if (config.state && (config.state as any).matches) {
    throw new Error(
      `Overmind statecharts: You have already defined the state "matches" in your configuration. Statecharts needs this, please rename it`
    )
  }

  return {
    onInitialize: ((context, instance) => {
      if (config.onInitialize) {
        config.onInitialize(context, instance)
      }
      
      currentInstance = instance
      const stateTarget = getTarget(
        context.state,
        context.execution.namespacePath
      )
      const actions = getTarget(
        context.actions,
        context.execution.namespacePath
      )

      const statePaths = stateTarget.states.slice()

      statePaths.forEach((statePath) => {
        const state = statePath.slice()
        while (state.length) {
          const target = getStateTarget(chart, state)

          if (target.entry) {
            actions[target.entry]()
          }

          state.pop()
        }
      })

      if (process.env.NODE_ENV === 'development' && instance.devtools) {
        instance.devtools.send({
          type: 'chart',
          data: {
            path: context.execution.namespacePath,
            states: getInitialStates(chart),
            chart: chart,
            actions: getCanTransitionActions(actions, chart, stateTarget),
          },
        })
      }
    }) as any,
    state: Object.assign(state, {
      states: getInitialStates(chart),
      actions: ((state) =>
        getCanTransitionActions(actions, chart, state)) as any,
      matches: (state) => (...args) => {
        return state.states.reduce((aggr, path) => {
          if (aggr) return aggr

          const cleanPath = path.filter((pathKey) => typeof pathKey !== 'number')
          for (let x = 0; x < args.length; x++) {
            if (args[x] !== cleanPath[x]) {
              return false
            }
          }

          return true
        }, false)
      },
    }),
    actions: Object.keys(actions).reduce((aggr, key) => {
      aggr[key] = pipe(
        map(function getTransition({ state, execution }: any, payload) {
          const stateTarget = getTarget(state, execution.namespacePath)

          return {
            transitions: getActionTransitions(key, chart, stateTarget),
            payload,
          }
        }),
        filter(function canTransition(_, { transitions }) {
          return transitions.some((transition) => transition !== false)
        }),
        mutate(function runAction(context: any, { transitions, payload }) {
          const stateTarget = getTarget(
            context.state,
            context.execution.namespacePath
          )
          const resolvedActions = getTarget(
            context.actions,
            context.execution.namespacePath
          )
          const newStates: Array<(string | number)[]> = []

          if (transitions.includes('entry') || transitions.includes('exit')) {
            actions[key](context, payload)
          }

          transitions.forEach((transition, index) => {
            const oldStatePath = stateTarget.states[index].slice()

            if (transition === 'entry' || transition === 'exit') {
              newStates.push(oldStatePath)
              return  
            }
            
            const currentStatePath = stateTarget.states[index].slice()
            const stateTransitions = currentStatePath.map(() => null)

            // Build new transition path
            while (currentStatePath.length) {
              const target = getStateTarget(chart, currentStatePath)

              // Collect the new transition state
              if (target.on && target.on[key]) {
                stateTransitions[currentStatePath.length - 1] =
                  target.on[key].target || target.on[key]
              }

              currentStatePath.pop()
            }

            const newStatePath = createNewStatePath(
              stateTarget.states,
              stateTransitions,
              chart,
              index
            )

            // Go down old path and trigger exits where the state has changed
            const traverseOldPath = oldStatePath.slice()
            while (traverseOldPath.length) {
              const target = getStateTarget(chart, traverseOldPath)

              if (
                target.exit &&
                newStatePath[traverseOldPath.length - 1] !==
                  oldStatePath[traverseOldPath.length - 1]
              ) {
                resolvedActions[target.exit]()
              }

              traverseOldPath.pop()
            }

            newStates.push(newStatePath.slice())

            // Go down new path and trigger any entry on new states
            const traverseNewPath = newStatePath.slice()
            while (traverseNewPath.length) {
              const target = getStateTarget(chart, traverseNewPath)

              if (
                target.entry &&
                newStatePath[traverseNewPath.length - 1] !==
                  oldStatePath[traverseNewPath.length - 1]
              ) {
                resolvedActions[target.entry]()
              }

              traverseNewPath.pop()
            }

            return actions[key](context, payload)
          })

          // Actually change what has changed
          stateTarget.states = newStates

          if (process.env.NODE_ENV === 'development' && currentInstance.devtools) {
            currentInstance.devtools.send({
              type: 'chart',
              data: {
                path: context.execution.namespacePath,
                states: stateTarget.states,
                chart: chart,
                actions: getCanTransitionActions(
                  config.actions,
                  chart,
                  stateTarget
                ),
              },
            })
          }
        })
      )

      return aggr
    }, {}),
    effects: config.effects || {},
  }
}
