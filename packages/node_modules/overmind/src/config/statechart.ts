import {
  IConfiguration,
  IConfig,
  pipe,
  filter,
  mutate,
  IDerive,
  map,
} from '../'

export interface Statechart<C extends IConfiguration, S extends string> {
  initial: S
  states: {
    [N in S]: Partial<Statechart<C, any>> & {
      entry?: keyof C['actions']
      exit?: keyof C['actions']
      on?: {
        [N in keyof C['actions']]?:
          | S
          | {
              target: S
              condition: (state: C['state']) => boolean
            }
          | null
      }
    }
  }
}

function getActionTransition(
  key: string,
  chart: Statechart<any, any>,
  state: { state: string[] }
) {
  const path = state.state.slice()
  let canTransition = false

  while (path.length) {
    const target = getStateTarget(chart, path)

    if (target.entry === key) return 'entry'
    if (target.exit === key) return 'exit'
    if (target.on && target.on[key] === null) return true
    if (target.on && typeof target.on[key] === 'string') return target.on[key]
    if (target.on && target.on[key] && target.on[key].condition(state))
      return target.on[key].target

    path.pop()
  }

  return false
}

function getCanTransitionActions(actions, chart, state) {
  return Object.keys(actions || {}).reduce((aggr, key) => {
    aggr[key] = Boolean(getActionTransition(key, chart, state))

    return aggr
  }, {})
}

function getInitialState(chart, path = []) {
  const newPath = path.concat(chart.initial)
  if (chart.states[chart.initial].initial) {
    return getInitialState(chart.states[chart.initial], newPath)
  }
  return newPath
}

function createNewStatePath(
  currentState: string[],
  transitionStates: string[],
  chart: Statechart<any, any>
) {
  const newStatePath: string[] = []
  let x = 0
  let transitionState = transitionStates.shift()

  // Keep existing state before transition
  while (!transitionState && transitionStates.length) {
    newStatePath.push(currentState[x])
    transitionState = transitionStates.shift()
  }

  if (!transitionState) {
    return currentState
  }

  // Add the new transition
  newStatePath.push(transitionState)

  const stateTarget = getStateTarget(chart, newStatePath)

  // If we have more nested state, go grab the initial states
  if (stateTarget.initial) {
    return newStatePath.concat(getInitialState(stateTarget))
  }

  return newStatePath
}

function getTarget(source, path) {
  return path.reduce((aggr, key) => aggr[key], source)
}

function getStateTarget(chart, path) {
  return path.reduce((aggr, key) => aggr.states[key], chart)
}

export function statechart<C extends IConfiguration, S extends string>(
  config: C,
  chart: Statechart<C, S>
): IConfig<{
  onInitialize: C['onInitialize']
  state: C['state'] & {
    state: S
    actions: { [N in keyof C['actions']]: boolean }
    matches: IDerive<any, any, (...args: string[]) => boolean>
  }
  actions: C['actions']
  effects: C['effects']
}> & {
  onInitialize: C['onInitialize']
} {
  let currentInstance
  const actions = config.actions || {}
  const state = config.state || {}

  return {
    onInitialize: ((context, instance) => {
      currentInstance = instance
      const stateTarget = getTarget(
        context.state,
        context.execution.namespacePath
      )
      const actions = getTarget(
        context.actions,
        context.execution.namespacePath
      )

      const statePath = stateTarget.state.slice()
      while (statePath.length) {
        const target = getStateTarget(chart, statePath)

        if (target.entry) {
          actions[target.entry]()
        }

        statePath.pop()
      }

      if (process.env.NODE_ENV === 'development') {
        instance.devtools.send({
          type: 'chart',
          data: {
            path: context.execution.namespacePath,
            state: getInitialState(chart),
            chart: chart,
            actions: getCanTransitionActions(actions, chart, stateTarget),
          },
        })
      }
    }) as any,
    state: Object.assign(state, {
      state: getInitialState(chart),
      actions: ((state) =>
        getCanTransitionActions(actions, chart, state)) as any,
      matches: (state) => (...args) => {
        for (let x = 0; x < args.length; x++) {
          if (args[x] !== state.state[x]) {
            return false
          }
        }

        return true
      },
    }),
    actions: Object.keys(actions).reduce((aggr, key) => {
      aggr[key] = pipe(
        map(function getTransition({ state, execution }: any, payload) {
          const stateTarget = getTarget(state, execution.namespacePath)

          return {
            transition: getActionTransition(key, chart, stateTarget),
            payload,
          }
        }),
        filter(function canTransition(_, { transition }) {
          return Boolean(transition)
        }),
        mutate(function changeState(context: any, { transition, payload }) {
          if (transition === 'entry' || transition === 'exit') {
            actions[key](context, payload)
            return
          }

          const stateTarget = getTarget(
            context.state,
            context.execution.namespacePath
          )
          const resolvedActions = getTarget(
            context.actions,
            context.execution.namespacePath
          )
          const oldStatePath = stateTarget.state.slice()
          const currentStatePath = stateTarget.state.slice()
          const stateTransitions = currentStatePath.map(() => null)

          actions[key](context, payload)

          // Build new transition path
          while (currentStatePath.length) {
            const target = getStateTarget(chart, currentStatePath)

            // Collect the new transition state
            if (target.on && target.on[key]) {
              stateTransitions[currentStatePath.length - 1] =
                target.on[key].target || target.on[key]
            }

            currentStatePath.pop()
          }

          const newStatePath = createNewStatePath(
            stateTarget.state,
            stateTransitions,
            chart
          )

          // Go down old path and trigger exits where the state has changed
          const traverseOldPath = oldStatePath.slice()
          while (traverseOldPath.length) {
            const target = getStateTarget(chart, traverseOldPath)

            if (
              target.exit &&
              newStatePath[traverseOldPath.length - 1] !==
                oldStatePath[traverseOldPath.length - 1]
            ) {
              resolvedActions[target.exit]()
            }

            traverseOldPath.pop()
          }

          if (newStatePath.join() !== oldStatePath.join()) {
            stateTarget.state = newStatePath.slice()
          }

          // Go down new path and trigger any entry on new states
          const traverseNewPath = newStatePath.slice()
          while (traverseNewPath.length) {
            const target = getStateTarget(chart, traverseNewPath)

            if (
              target.entry &&
              newStatePath[traverseNewPath.length - 1] !==
                oldStatePath[traverseNewPath.length - 1]
            ) {
              resolvedActions[target.entry]()
            }

            traverseNewPath.pop()
          }

          if (process.env.NODE_ENV === 'development') {
            currentInstance.devtools.send({
              type: 'chart',
              data: {
                path: context.execution.namespacePath,
                state: stateTarget.state,
                chart: chart,
                actions: getCanTransitionActions(
                  config.actions,
                  chart,
                  stateTarget
                ),
              },
            })
          }
        })
      )

      return aggr
    }, {}),
    effects: config.effects || {},
  }
}
