import { IAction, createOvermind } from '../'
import { Statechart, statechart } from './'

describe.only('Statecharts', () => {
  test('should wrap configs', () => {
    const config = {}

    const chart: Statechart<typeof config, 'foo'> = {
      initial: 'foo',
      states: {
        foo: {},
      },
    }
    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo'])
    expect(instance.state.actions).toEqual({})
    expect(instance.state.matches('foo')).toEqual(true)
  })
  test('should filter actions', () => {
    const increaseCount: Action = ({ state }) => {
      state.count++
    }

    const config = {
      state: {
        count: 0,
      },
      actions: {
        increaseCount,
      },
    }

    const chart: Statechart<typeof config, 'foo' | 'bar'> = {
      initial: 'foo',
      states: {
        foo: {
          on: {
            increaseCount: 'bar',
          },
        },
        bar: {},
      },
    }

    interface Action<Input = void, Output = void>
      extends IAction<typeof config, Input, Output> {}

    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo'])
    expect(instance.state.actions).toEqual({ increaseCount: true })
    expect(instance.state.matches('foo')).toEqual(true)

    instance.actions.increaseCount()

    expect(instance.state.state).toEqual(['bar'])
    expect(instance.state.actions).toEqual({ increaseCount: false })
    expect(instance.state.matches('bar')).toEqual(true)
    expect(instance.state.count).toBe(1)
  })
  test('should run entry action', () => {
    const increaseCount: Action = ({ state }) => {
      state.count++
    }

    const config = {
      state: {
        count: 0,
      },
      actions: {
        increaseCount,
      },
    }

    const chart: Statechart<typeof config, 'foo'> = {
      initial: 'foo',
      states: {
        foo: {
          entry: 'increaseCount',
        },
      },
    }

    interface Action<Input = void, Output = void>
      extends IAction<typeof config, Input, Output> {}

    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo'])
    expect(instance.state.actions).toEqual({ increaseCount: true })
    expect(instance.state.matches('foo')).toEqual(true)
    expect(instance.state.count).toBe(1)
  })
  test('should run exit action', () => {
    const increaseCount: Action = ({ state }) => {
      state.count++
    }
    const changeToBar: Action = () => {}

    const config = {
      state: {
        count: 0,
      },
      actions: {
        increaseCount,
        changeToBar,
      },
    }

    const chart: Statechart<typeof config, 'foo' | 'bar'> = {
      initial: 'foo',
      states: {
        foo: {
          exit: 'increaseCount',
          on: {
            changeToBar: 'bar',
          },
        },
        bar: {},
      },
    }

    interface Action<Input = void, Output = void>
      extends IAction<typeof config, Input, Output> {}

    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo'])
    expect(instance.state.actions).toEqual({
      increaseCount: true,
      changeToBar: true,
    })
    expect(instance.state.matches('foo')).toEqual(true)

    instance.actions.changeToBar()

    expect(instance.state.state).toEqual(['bar'])
    expect(instance.state.actions).toEqual({
      increaseCount: false,
      changeToBar: false,
    })
    expect(instance.state.matches('bar')).toEqual(true)
    expect(instance.state.count).toBe(1)
  })
  test('should filter actions by condition', () => {
    const increaseCount: Action = ({ state }) => {
      state.count++
    }
    const changeToBar: Action = () => {}

    const config = {
      state: {
        count: 0,
      },
      actions: {
        increaseCount,
        changeToBar,
      },
    }

    const chart: Statechart<typeof config, 'foo' | 'bar'> = {
      initial: 'foo',
      states: {
        foo: {
          on: {
            increaseCount: null,
            changeToBar: {
              target: 'bar',
              condition: (state) => state.count > 0,
            },
          },
        },
        bar: {},
      },
    }

    interface Action<Input = void, Output = void>
      extends IAction<typeof config, Input, Output> {}

    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo'])
    expect(instance.state.actions).toEqual({
      increaseCount: true,
      changeToBar: false,
    })
    expect(instance.state.matches('foo')).toEqual(true)

    instance.actions.increaseCount()

    expect(instance.state.actions).toEqual({
      increaseCount: true,
      changeToBar: true,
    })

    instance.actions.changeToBar()

    expect(instance.state.state).toEqual(['bar'])
    expect(instance.state.actions).toEqual({
      increaseCount: false,
      changeToBar: false,
    })
    expect(instance.state.matches('bar')).toEqual(true)
  })
  test.only('should allow nesting', () => {
    const fooEntry: Action = ({ state }) => {
      state.transitions.push('fooEntry')
    }
    const fooExit: Action = ({ state }) => {
      state.transitions.push('fooExit')
    }
    const aEntry: Action = ({ state }) => {
      state.transitions.push('aEntry')
    }
    const aExit: Action = ({ state }) => {
      state.transitions.push('aExit')
    }
    const bExit: Action = ({ state }) => {
      state.transitions.push('bExit')
    }
    const changeToBar: Action = () => {}
    const changeToB: Action = () => {}

    const config = {
      state: {
        transitions: [] as string[],
      },
      actions: {
        fooEntry,
        fooExit,
        aEntry,
        aExit,
        bExit,
        changeToBar,
        changeToB,
      },
    }

    const nestedChart: Statechart<typeof config, 'a' | 'b'> = {
      initial: 'a',
      states: {
        a: {
          entry: 'aEntry',
          exit: 'aExit',
          on: {
            changeToB: 'b',
          },
        },
        b: {
          exit: 'bExit',
        },
      },
    }

    const chart: Statechart<typeof config, 'foo' | 'bar'> = {
      initial: 'foo',
      states: {
        foo: {
          entry: 'fooEntry',
          exit: 'fooExit',
          on: {
            changeToBar: 'bar',
          },
          ...nestedChart,
        },
        bar: {},
      },
    }

    interface Action<Input = void, Output = void>
      extends IAction<typeof config, Input, Output> {}

    const instance = createOvermind(statechart(config, chart))

    expect(instance.state.state).toEqual(['foo', 'a'])
    expect(instance.state.actions).toEqual({
      fooEntry: true,
      fooExit: true,
      aEntry: true,
      aExit: true,
      bExit: false,
      changeToBar: true,
      changeToB: true,
    })
    expect(instance.state.transitions).toEqual(['aEntry', 'fooEntry'])
    instance.actions.changeToB()
    expect(instance.state.state).toEqual(['foo', 'b'])
    expect(instance.state.actions).toEqual({
      fooEntry: true,
      fooExit: true,
      aEntry: false,
      aExit: false,
      bExit: true,
      changeToBar: true,
      changeToB: false,
    })
    expect(instance.state.transitions).toEqual(['aEntry', 'fooEntry', 'aExit'])
    instance.actions.changeToBar()
    expect(instance.state.state).toEqual(['bar'])
    expect(instance.state.actions).toEqual({
      fooEntry: false,
      fooExit: false,
      aEntry: false,
      aExit: false,
      bExit: false,
      changeToBar: false,
      changeToB: false,
    })
    expect(instance.state.transitions).toEqual([
      'aEntry',
      'fooEntry',
      'aExit',
      'bExit',
      'fooExit',
    ])
  })
})
