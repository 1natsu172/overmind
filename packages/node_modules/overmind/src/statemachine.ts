import { PROXY_TREE, VALUE } from 'proxy-state-tree'

import { IState } from '.'

type TStates = IState & {
  state: string | number,
}

export type StatemachineTransitions<States extends TStates> = {
  [State in States["state"]]: Array<States["state"]>
}

export interface MachineMethods<States extends TStates> {
  reset: () => void
  matches<T extends States["state"][]>(...states: T): this is Statemachine<States, States extends {
    state: T extends Array<infer S> ? S : never;
} ? States : never>;
  transition<State extends States["state"]>(
    state: State,
    entry?:  (current: Statemachine<States, States extends { state: State } ? States : never>) => void,
    exit?: (current: Statemachine<States, States extends { state: State } ? States : never>) => void
  ): Promise<void>
  whenTransitioned: (state: States["state"]) => Promise<void>
}

export type Statemachine<States extends TStates, State extends TStates = States> = State & MachineMethods<States>

const CURRENT_EXIT = Symbol('CURRENT_EXIT')
const INITIAL_STATE = Symbol('INITIAL_STATE')
const TRANSITIONS = Symbol('TRANSITIONS')
const PENDING_TRANSITIONS = Symbol('PENDING_TRANSITIONS')

class StateMachine<States extends TStates, State extends TStates = States>  {
  state: State["state"]
  private [CURRENT_EXIT]: (() => void) | undefined
  private [INITIAL_STATE]: State["state"]
  private [PENDING_TRANSITIONS]: { [key: string]: Function[] } = {}
  constructor(transitions: StatemachineTransitions<States>, definition: States) {
    this[INITIAL_STATE] = definition.state
    this[TRANSITIONS] = transitions
    Object.assign(this, definition)
  }
  transition(state, entry, exit) {
    const transitions = this[VALUE][TRANSITIONS]
    if (transitions[this.state].includes(state)) {
      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])
      let exitResult
      tree.enableMutations()
      
      if (this[CURRENT_EXIT]) this[CURRENT_EXIT]!()
      if (exit) {
        exitResult = new Promise((resolve) => {
          this[VALUE][CURRENT_EXIT] = () => resolve(exit(this))
        })
      } else {
        this[VALUE][CURRENT_EXIT] = undefined
      }
      this.state = state
      const entryResult = entry && entry(this)

      tree.blockMutations()

      if (this[VALUE][PENDING_TRANSITIONS][this.state]) {
        this[VALUE][PENDING_TRANSITIONS][this.state].forEach((resolve) => resolve())
        this[VALUE][PENDING_TRANSITIONS][this.state] = []
      }

      return exitResult || entryResult
    } else if (process.env.NODE_ENV === 'development') {
      console.warn(`Overmind Statemachine - You tried to transition into "${state}", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.state])}`)
    }
  }
  matches(...states) {
    if (states.includes(this.state)) {
      return true
    }

    return false
  }
  reset() {
    const exit = this[VALUE][CURRENT_EXIT]
    if (typeof exit === 'function') {
      exit()
      this[VALUE][CURRENT_EXIT] = undefined
    }
    this.state = this[INITIAL_STATE]
  }
  whenTransitioned(state: States["state"]) {
    if (!this[VALUE][PENDING_TRANSITIONS][state]) {
      this[VALUE][PENDING_TRANSITIONS][state] = []
    }

    return new Promise((resolve) => {
      this[VALUE][PENDING_TRANSITIONS][state].push(resolve)
    })
  }
}

export function statemachine<States extends TStates>(definition: StatemachineTransitions<States>, state: States): Statemachine<States> {
  return new StateMachine(definition, state) as any
}
