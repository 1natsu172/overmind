import { IS_PRODUCTION, IS_OPERATOR, makeStringifySafeMutations } from './utils'
import { EventType } from './internalTypes'
import { safeValue } from './Devtools'
import { IContext, IConfiguration } from './types'

export function startDebugOperator(type, arg, context) {
  if (IS_PRODUCTION) {
    return
  }
  const name =
    typeof arg === 'function' ? arg.displayName || arg.name : String(arg)

  context.execution.emit(EventType.OPERATOR_START, {
    ...context.execution,
    name,
    type,
  })
}

export function stopDebugOperator(context, value) {
  if (IS_PRODUCTION) {
    return
  }

  if (value instanceof Promise) {
    value.then((promiseValue) => {
      context.execution.emit(EventType.OPERATOR_END, {
        ...context.execution,
        result: safeValue(promiseValue),
        isAsync: true,
      })
    })
  } else {
    context.execution.emit(EventType.OPERATOR_END, {
      ...context.execution,
      result: safeValue(value),
      isAsync: false,
    })
  }
}

export function createContext(context, value, path?) {
  if (IS_PRODUCTION) {
    return {
      ...context,
      value,
    }
  }

  const newExecution = {
    ...context.execution,
    operatorId: context.execution.operatorId + 1,
    path: path || context.execution.path,
  }

  return {
    ...context,
    value,
    execution: newExecution,
    effects: context.execution.trackEffects(newExecution),
  }
}

export function createNextPath(next) {
  if (IS_PRODUCTION) {
    return next
  }

  return (err, context) => {
    const newContext = {
      ...context,
      execution: {
        ...context.execution,
        path: context.execution.path.slice(
          0,
          context.execution.path.length - 1
        ),
      },
    }
    if (err) next(err, newContext)
    else next(null, newContext)
  }
}

export function createOperator<ThisConfig extends IConfiguration>(
  type: string,
  name: string,
  cb: (
    err: Error | null,
    context: IContext<ThisConfig>,
    value: any,
    next: (
      err: Error | null,
      value: any,
      path?: { name: string; operator: Function }
    ) => void,
    final: (err: Error | null, value: any) => void
  ) => any
): any {
  const operator = (err, context, next, final) => {
    startDebugOperator(type, name, context)
    try {
      cb(
        err,
        {
          state: context.state,
          effects: context.effects,
          actions: context.actions,
        },
        context.value,
        (err, value, path?) => {
          if (path) {
            const newContext = createContext(
              context,
              value,
              context.execution.path && context.execution.path.concat(path.name)
            )
            const nextWithPath = createNextPath(next)
            stopDebugOperator(context, value)
            path.operator(err, newContext, nextWithPath)
          } else {
            stopDebugOperator(context, value)
            next(err, createContext(context, value))
          }
        },
        (err, value) => {
          stopDebugOperator(context, value)
          final(err, createContext(context, value))
        }
      )
    } catch (error) {
      stopDebugOperator(context, context.value)
      next(error, createContext(context, context.value))
    }
  }

  operator[IS_OPERATOR] = true

  return operator
}

export function createMutationOperator<ThisConfig extends IConfiguration>(
  type: string,
  name: string,
  cb: (
    err: Error | null,
    context: IContext<ThisConfig>,
    value: any,
    next: (err: Error | null, value: any) => void,
    final: (err: Error | null, value: any) => void
  ) => any
): any {
  const operator = (err, context, next, final) => {
    startDebugOperator(type, name, context)
    const mutationTree = context.execution.getMutationTree()
    if (!IS_PRODUCTION) {
      mutationTree.onMutation((mutation) => {
        context.execution.emit(EventType.MUTATIONS, {
          ...context.execution,
          mutations: makeStringifySafeMutations([mutation]),
        })
        setTimeout(() => {
          const flushData = mutationTree.flush(true)
          if (flushData.mutations.length) {
            context.execution.send({
              type: 'flush',
              data: {
                ...context.execution,
                ...flushData,
                mutations: makeStringifySafeMutations(flushData.mutations),
              },
            })
          }
        })
      })
    }
    try {
      cb(
        err,
        {
          state: mutationTree.state,
          effects: context.effects,
          actions: context.actions,
        },
        IS_PRODUCTION
          ? context.value
          : context.execution.scopeValue(context.value, mutationTree),
        (err, value) => {
          stopDebugOperator(context, value)
          next(err, createContext(context, value))
        },
        (err, value) => {
          stopDebugOperator(context, value)
          final(err, createContext(context, value))
        }
      )
    } catch (error) {
      stopDebugOperator(context, context.value)
      next(error, createContext(context, context.value))
    }
  }

  operator[IS_OPERATOR] = true

  return operator
}
