import { IMutation } from 'proxy-state-tree'

import { IState } from './types'

export function rehydrateState(target: any, source: any, classes: any = {}) {
  if (!target || !source) {
    throw new Error(`You have to pass a "target" and "source" object to rehydrate`)
  }

  Object.keys(source).forEach((key) => {
    const value = source[key]
    const classInstance = classes[key]
    
    if (typeof classInstance === 'function' && Array.isArray(target[key])) {
      target[key] = (source[key] as any[]).map(value => classInstance(value))
    } else if (typeof classInstance === 'function' && typeof target[key] === 'object' && target[key] !== null && target[key].constructor.name === 'Object') {
      target[key] = Object.keys(source[key] as any).reduce((aggr, subKey) => {
        aggr[subKey] = classInstance((source[key] as any)[subKey])
        
        return aggr
      }, {})
    } else if (typeof classInstance === 'function') {
      target[key] = classInstance(source[key])
    } else if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
      if (!target[key]) target[key] = {}
      rehydrateState(target[key] as IState, source[key] as IState, classes[key])
    } else {
      target[key] = source[key]
    }
  })
}

export const SERIALIZE = Symbol('SERIALIZE')

export interface Serialize {
  [SERIALIZE]: boolean
} 

export type Serializable = Serialize | {
  toJSON: () => {
    [SERIALIZE]: boolean
  }
}

export type RehydrateClasses<T extends IState> = Pick<{
  [P in keyof T]: T[P] extends Serializable ? (data: any) => T[P] :
      T[P] extends Array<Serializable> ? (data: any) => T[P][keyof T[P]] :
      T[P] extends { [key: string]: Serializable } ? (data: any) => T[P][keyof T[P]] :
      T[P] extends IState ? RehydrateClasses<T[P]> :
      never
},{ [Key in keyof T]: T[Key] extends Serializable | Array<Serializable> | { [key: string]: Serializable } ? Key : never }[keyof T]>


export const rehydrate = <T extends IState>(state: T, source: IMutation[] | IState, classes: RehydrateClasses<T> = {} as any) => {
  if (Array.isArray(source)) {
    const mutations = source as IMutation[]
    mutations.forEach((mutation) => {
      const pathArray = mutation.path.split('.')
      const key = pathArray.pop() as string
      const target = pathArray.reduce((aggr, key) => aggr[key], state as any)
      const classInstance = pathArray.reduce((aggr, key) => aggr[key], classes as any)
  
      if (mutation.method === 'set') {
        if (typeof classInstance === 'function' && Array.isArray(mutation.args[0])) {
          target[key] = mutation.args[0].map((arg) => classInstance(arg))
        } else if (typeof classInstance === 'function') {
          target[key] = classInstance(mutation.args[0])
        } else {
          target[key] = mutation.args[0]
        }
      } else if (mutation.method === 'unset') {
        delete target[key]
      } else {
        target[key][mutation.method].apply(target[key], typeof classInstance === 'function' ? mutation.args.map((arg) => {
          return typeof arg === 'object' && arg !== null ? classInstance(arg) : arg
        }) : mutation.args)
      }
    })
  } else {
    rehydrateState(state, source, classes)
  } 
}