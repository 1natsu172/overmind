import { EventEmitter } from 'betsy'
import {
  ProxyStateTree,
  VALUE,
  IS_PROXY,
  ITrackStateTree,
  TrackStateTree,
  IMutationTree,
  MutationTree,
} from 'proxy-state-tree'

import { EventType, Events } from './internalTypes'

export class Derived {
  private isDirty: boolean = true
  private trackStateTree: ITrackStateTree<any>
  private previousTreeAccess: any
  private value: any
  private paths: Set<string>
  private updateCount: number = 0
  private disposeOnMutation: () => void
  constructor(private cb: (state: object, parent: object) => void) {
    const boundEvaluate: any = this.evaluate.bind(this)

    if (process.env.NODE_ENV === 'development') {
      boundEvaluate.dispose = () => {
        this.disposeOnMutation()
        this.trackStateTree.dispose()
      }
    }

    return boundEvaluate
  }
  private createScope(tree, path) {
    const pathAsArray = path.split('.')
    pathAsArray.pop()
    const parent = pathAsArray.reduce((curr, key) => curr[key], tree.state)

    return () => this.cb(parent, tree.state)
  }
  evaluate(
    eventHub: EventEmitter<Events>,
    tree: ITrackStateTree<any> | IMutationTree<any>,
    proxyStateTree: ProxyStateTree<any>,
    path
  ) {
    if (!this.trackStateTree) {
      this.trackStateTree = proxyStateTree.getTrackStateTree()
      this.trackStateTree.shouldTrack = true
      this.trackStateTree.callback = () => {
        this.isDirty = true
      }

      if (process.env.NODE_ENV === 'development') {
        this.disposeOnMutation = proxyStateTree.onMutation(
          (_, paths, flushId) => {
            if (this.isDirty) {
              return
            }

            for (let mutationPath of paths) {
              if (this.paths.has(mutationPath)) {
                this.isDirty = true
                eventHub.emitAsync(EventType.DERIVED_DIRTY, {
                  derivedPath: path,
                  path: mutationPath,
                  flushId,
                })
                return
              }
            }
          }
        )
      }
    }

    let isDirty

    // During development we need to re-evaluate the derived so that
    // it tracks on the mutation tree passed in, in case of mutations
    // of the returned derived
    if (process.env.NODE_ENV === 'development') {
      isDirty =
        this.isDirty ||
        (tree instanceof MutationTree && this.previousTreeAccess !== tree)
    } else {
      isDirty = this.isDirty
    }

    if (isDirty) {
      const getPaths = tree.trackPaths()

      this.value = this.createScope(tree, path)()
      this.isDirty = false
      this.paths = getPaths()

      // We add the paths to the derived
      this.trackStateTree.pathDependencies.clear()

      for (let path of this.paths) {
        this.trackStateTree.addTrackingPath(path)
      }

      if (process.env.NODE_ENV === 'development') {
        eventHub.emitAsync(EventType.DERIVED, {
          path,
          paths: Array.from(this.paths),
          updateCount: this.updateCount,
          value: this.value,
        })
        this.updateCount++
      }
    }

    this.previousTreeAccess = tree

    return this.value
  }
}
