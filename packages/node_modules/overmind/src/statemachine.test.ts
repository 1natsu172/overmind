import { IAction , createOvermind, createOvermindMock } from './'

import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  test('should set initial state', () => {

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }
    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.machine.current).toBe('FOO')
  })
  test('should transition state', () => {

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('BAR')
  })
  test('should ignore transition to invalid state', () => {

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: [],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('FOO')
  })
  test('should run entry and exit transition', () => {
    expect.assertions(3)
    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR(() => {
        expect(state.machine.current).toBe('BAR')
        state.machine.FOO()
      }, () => {
        expect(state.machine.current).toBe('BAR')
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('FOO')
  })
  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.machine.current, (value) => {
      expect(value).toBe('BAR')
    })
    overmind.actions.transition()
  })
})
