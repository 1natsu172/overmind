import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.state).toBe('FOO')
  })
  test('should transition state', () => {
    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.state).toBe('BAR')
  })
  test('should ignore transition to invalid state', () => {

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: [],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
  })
  test('should run entry and exit transition', async () => {
    expect.assertions(3)
    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      return state.transition('BAR', () => {
        expect(state.state).toBe('BAR')
        state.transition('FOO')
      }, () => {
        expect(state.state).toBe('BAR')
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermindMock(config)
    await overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
  })
  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.state, (value) => {
      expect(value).toBe('BAR')
    })
    overmind.actions.transition()
  })
  
  test('should error when mutating async in transitions', async () => {
    expect.assertions(1)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    const transition: Action = ({ state }) => {
      return state.transition('BAR', async () => {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })

  test('should reset a statemachine', () => {
    expect.assertions(1)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.actions.transition()
    overmind.state.reset()
    expect(overmind.state.state).toBe('FOO')
  })

  test('should pass statemachine to transition callback, correctly typed', () => {
    expect.assertions(3)

    type States = {
      state: 'FOO'
      foo: string
    } | {
      state: 'BAR'
      bar: string
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        state: 'FOO',
        foo: 'bar'
      })
    
    const transition: Action = ({ state }) => {
      return state.transition('BAR', () => {
        state.transition('FOO', (current) => {
          current.foo = 'bar2'
        })
      }, (current) => {
        current.bar = 'baz2'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermind(config)
    overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
    // @ts-ignore
    expect(overmind.state.foo).toBe('bar2')
    // @ts-ignore
    expect(overmind.state.bar).toBe('baz2')
  })

  test('should allow async exit transition', async () => {
    expect.assertions(3)

    type States = {
      state: 'FOO'
      foo: string
    } | {
      state: 'BAR'
      bar: string
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        state: 'FOO',
        foo: 'bar'
      })
    
    const transition: Action = ({ state }) => {
      return state.transition('BAR', async () => {
        await Promise.resolve()
        state.transition('FOO', (current) => {
          current.foo = 'bar2'
        })
      }, (current) => {
        current.bar = 'baz2'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermind(config)
    await overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
    // @ts-ignore
    expect(overmind.state.foo).toBe('bar2')
    // @ts-ignore
    expect(overmind.state.bar).toBe('baz2')
  })
})
