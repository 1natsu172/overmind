import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.state).toBe('FOO')
  })
  test('should transition state', () => {
    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.state).toBe('BAR')
  })
  test('should ignore transition to invalid state', () => {

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: [],
      BAR: ['FOO']
    }, {
      state: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
  })
  test('should run entry and exit transition', async () => {
    expect.assertions(3)
    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      if (state.transition('BAR')) {
        expect(state.state).toBe('BAR')
        state.transition('FOO')
        expect(state.state).toBe('FOO')
      }
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermindMock(config)
    await overmind.actions.transition()
    expect(overmind.state.state).toBe('FOO')
  })
  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      state.transition('BAR')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.state, (value) => {
      expect(value).toBe('BAR')
    })
    overmind.actions.transition()
  })
  
  test('should error when mutating async in transitions', async () => {
    expect.assertions(1)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    const transition: Action = async ({ state }) => {
      if (state.transition('BAR')) {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
      }
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })
  test('should enable mutations after new async matching or transition', async () => {
    expect.assertions(3)

    type States = {
      state: 'FOO'
    } | {
      state: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        state: 'FOO'
      })
    const transition: Action = async ({ state }) => {
      if (state.transition('BAR')) {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
        if (state.matches('BAR')) {
          expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(false)
          await Promise.resolve()
          if (state.transition('FOO')) {
            expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(false)
          }
        }
      }
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })
})
