import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }
    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.machine.current).toBe('FOO')
  })
  test.only('should transition state', () => {
    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('BAR')
  })
  test('should ignore transition to invalid state', () => {

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: [],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('FOO')
  })
  test('should run entry and exit transition', () => {
    expect.assertions(3)
    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR(() => {
        expect(state.machine.current).toBe('BAR')
        state.machine.FOO()
      }, () => {
        expect(state.machine.current).toBe('BAR')
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.machine.current).toBe('FOO')
  })
  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      })
    }
    const transition: Action = ({ state }) => {
      state.machine.BAR()
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.machine.current, (value) => {
      expect(value).toBe('BAR')
    })
    overmind.actions.transition()
  })
  
  test('should error when mutating async in transitions', async () => {
    expect.assertions(1)

    type State = {
      machine: Statemachine<'FOO' | 'BAR'>
      foo: string
    }

    const state: State = {
      machine: statemachine<'FOO' | 'BAR'>({
        initial: 'FOO',
        states: {
          FOO: ['BAR'],
          BAR: ['FOO']
        }
      }),
      foo: 'bar'
    }
    const transition: Action = ({ state }) => {
      return state.machine.BAR(async () => {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })
})
