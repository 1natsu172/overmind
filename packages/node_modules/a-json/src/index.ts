// Symbol used as placeholders for objects and arrays
const IS_ARRAY = Symbol("IS_ARRAY");
const IS_OBJECT = Symbol("IS_OBJECT");

let ASYNC_BATCH_COUNT = 3000;
let TRACK_PERF = false;

export const tweak = (batchCount, trackPerf) => {
  ASYNC_BATCH_COUNT = batchCount;
  TRACK_PERF = Boolean(trackPerf);
};

const next =
  (typeof window !== "undefined" && window.requestAnimationFrame) || setTimeout;

/*
  This function takes a value which results in a Map of
  path to a value and placeholder IS_ARRAY/IS_OBJECT, or the static
  value. It takes a "replacer" function which allows you to intercept
  the created result
*/
function getPaths(value, paths, replacer, currentPath = []) {
  const replacedValue = replacer ? replacer(currentPath, value) : value;
  if (
    typeof replacedValue === "function" ||
    typeof replacedValue === "symbol"
  ) {
  } else if (Array.isArray(replacedValue)) {
    paths.set(currentPath.slice(), IS_ARRAY);
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer, currentPath);
      currentPath.pop();
    }
  } else if (replacedValue !== null && typeof replacedValue === "object") {
    paths.set(currentPath.slice(), IS_OBJECT);
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer, currentPath);
      currentPath.pop();
    }
  } else {
    paths.set(currentPath.slice(), replacedValue);
  }

  return paths;
}

/*
  When parsing we replace all objects and arrays with a reference first,
  then we async resolve them. This function identifies a ref
*/
function isRef(ref) {
  if (typeof ref === "string" && ref.match(/\$\$REF_[0-9]/)) {
    return ref;
  }

  return null;
}

/*
  This function takes value with an optional replacer. It will stringify
  the values async by first creating a MAP of all paths, as explained above.
  Then it iterates these paths and produces the JSON string
*/
export function stringify(value, replacer?) {
  return new Promise(resolve => {
    next(async () => {
      const paths = getPaths(value, new Map(), replacer);
      const structs = [];
      let prevKey = [];
      let string = "";
      let x = 0;
      let start;
      if (TRACK_PERF) {
        start = performance.now();
      }
      for (let [key, value] of paths) {
        if (x % ASYNC_BATCH_COUNT === 0) {
          if (TRACK_PERF) {
            const end = performance.now();
            console.log("PERF stringify", end - start);
            start = end;
          }

          await new Promise(resolve => next(resolve));
        }

        x++;

        const currentKey = prevKey;

        prevKey = key;

        if (
          // If we are moving back up the tree, previous has to have been
          // an object or array
          (key.length && currentKey.length > key.length) ||
          // Or we stay at the same nested level, but previous was
          // an object or key
          (currentKey.length === key.length &&
            (paths.get(currentKey) === IS_OBJECT ||
              paths.get(currentKey) === IS_ARRAY))
        ) {
          string += structs.pop() === IS_OBJECT ? "}" : "]";
        }

        if (key.length && key.length <= currentKey.length) {
          string += ",";
        }

        if (value === IS_OBJECT) {
          const currentStruct = structs[structs.length - 1];
          structs.push(value);
          string +=
            key.length && currentStruct === IS_OBJECT
              ? `"${key[key.length - 1]}":{`
              : "{";
          continue;
        }

        if (value === IS_ARRAY) {
          const currentStruct = structs[structs.length - 1];
          structs.push(value);
          string +=
            key.length && currentStruct === IS_OBJECT
              ? `"${key[key.length - 1]}":[`
              : "[";
          continue;
        }

        const currentStruct = structs[structs.length - 1];
        if (currentStruct === IS_OBJECT) {
          string += `"${key[key.length - 1]}":${JSON.stringify(value)}`;
          continue;
        }
        if (currentStruct === IS_ARRAY) {
          string += JSON.stringify(value);
          continue;
        }
      }

      while (structs.length) {
        const struct = structs.pop();
        string += struct === IS_OBJECT ? "}" : "]";
      }

      resolve(string);
    });
  });
}

/*
  This function takes a JSON string and async parses it. It does this by looking
  tracking all "{", "[" and then when finding their end parts, "}" and "]", replaces
  the object/array with a reference. Each reference is then async parsed and 
  built back together
*/
export async function parse(value) {
  let refId = 0;
  const references = {};
  const openingObjectBrackets = [];
  const openingArrayBrackets = [];

  let isInString = false;
  let start;
  if (TRACK_PERF) {
    start = performance.now();
  }
  for (let charIndex = 0; charIndex < value.length; charIndex++) {
    if (charIndex % ASYNC_BATCH_COUNT === 0) {
      if (TRACK_PERF) {
        const end = performance.now();
        console.log("PERF parse", end - start);
        start = end;
      }
      await new Promise(resolve => next(resolve));
    }
    if (value[charIndex] === '"') {
      isInString = !isInString;
      continue;
    }

    if (isInString) {
      continue;
    }

    if (value[charIndex] === "{") {
      openingObjectBrackets.push(charIndex);
    } else if (value[charIndex] === "[") {
      openingArrayBrackets.push(charIndex);
    } else if (value[charIndex] === "}") {
      const openingBracketIndex = openingObjectBrackets.pop();
      const id = `$$REF_${refId++}`;
      references[id] = value.substr(
        openingBracketIndex,
        charIndex - openingBracketIndex + 1
      );
      value =
        value.substr(0, openingBracketIndex) +
        `"${id}"` +
        value.substr(charIndex + 1);

      charIndex = openingBracketIndex + id.length + 1;
    } else if (value[charIndex] === "]") {
      const openingBracketIndex = openingArrayBrackets.pop();
      const id = `$$REF_${refId++}`;
      references[id] = value.substr(
        openingBracketIndex,
        charIndex - openingBracketIndex + 1
      );
      value =
        value.substr(0, openingBracketIndex) +
        `"${id}"` +
        value.substr(charIndex + 1);
      charIndex = openingBracketIndex + id.length + 1;
    }
  }

  async function produceResult(value, i) {
    let parsedValue = JSON.parse(value);

    const keys = Object.keys(parsedValue);

    if (i % ASYNC_BATCH_COUNT === 0) {
      await new Promise(resolve => next(resolve));
    }

    return Promise.all(
      keys.map(async (key, index) => {
        const value = parsedValue[key];
        i++;
        if (isRef(value)) {
          parsedValue[key] = await produceResult(references[value], i + index);
        }
      })
    ).then(() => parsedValue);
  }

  let initialValue = JSON.parse(value);
  if (isRef(initialValue)) {
    initialValue = references[initialValue];
  }

  return produceResult(initialValue, 0);
}
