import { EventType, IConfiguration, Overmind } from 'overmind'
import { VALUE } from 'proxy-state-tree'
import * as snabbdom from 'snabbdom'
import h from 'snabbdom/h'
import attributesModule from 'snabbdom/modules/attributes'
import classModule from 'snabbdom/modules/class'
import eventlistenersModule from 'snabbdom/modules/eventlisteners'
import propsModule from 'snabbdom/modules/props'
import styleModule from 'snabbdom/modules/style'
import thunk from 'snabbdom/thunk'

import { SELF, getName, normalizeAttrs } from './utils'

const patch = snabbdom.init([
  classModule,
  propsModule,
  attributesModule,
  styleModule,
  eventlistenersModule,
])

let _app

export interface IComponent<Config extends IConfiguration, Props = {}> {
  (
    props: Props,
    overmind: {
      state: Overmind<Config>['state']
      actions: Overmind<Config>['actions']
      effects: Overmind<Config>['effects']
    }
  ): any
}

declare global {
  namespace JSX {
    interface IntrinsicElements {
      self: React.DetailedHTMLProps<
        React.HtmlHTMLAttributes<HTMLHtmlElement> & {
          onMount?: (el: HTMLElement) => void | (() => void)
        },
        HTMLHtmlElement
      >
    }
  }
}

declare module 'react' {
  interface HTMLAttributes<T>
    extends React.AriaAttributes,
      React.DOMAttributes<T> {
    onInsert?: (el: HTMLElement) => void
    onUpdate?: (el: HTMLElement) => void
    onDestroy?: (el: HTMLElement) => void
    onEnter?: (el: HTMLElement) => void
    onLeave?: (el: HTMLElement) => void
    class?: {
      [key: string]: boolean
    }
  }
}

const thunks = new Map()

let nextId = 0
let nextComponentId = {}
let nextComponentInstanceId = {}

export const createElement = (tag, attrs, ...children) => {
  if (typeof tag === 'function') {
    const memo = Object.keys(attrs || {}).reduce(
      (aggr, key) => {
        const value = attrs[key]
        if (value && value[VALUE] && !value[VALUE].__rescope) {
          Object.defineProperty(value[VALUE], '__rescope', {
            get: () => {
              return (tree) => _app.proxyStateTree.rescope(value, tree)
            },
          })
        }
        return [...aggr, key, value && value[VALUE] ? value[VALUE] : value]
      },
      children.length
        ? ['children', children.reduce((aggr, item) => aggr.concat(item), [])]
        : []
    )

    const name = getName(tag.name)
    return thunk(
      name,
      attrs && attrs.key,
      thunks.get(tag) ||
        thunks
          .set(tag, (...props) => {
            const tree = _app.proxyStateTree.getTrackStateTree()
            const propsObject = {}
            while (props.length) {
              const [key, value] = props.splice(0, 2)
              propsObject[key] =
                value && value.__rescope ? value.__rescope(tree) : value
            }
            let vnode
            let elm

            function onFlush(_, __, flushId) {
              if (elm.__overmind.tree !== tree) {
                tree.dispose()
                return
              }

              tree.track(update)

              const newNode = tag(propsObject, {
                state: tree.state,
                actions: _app.actions,
              })
              tree.stopTracking()

              patch(vnode, newNode)
              vnode = newNode

              _app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: elm.__overmind.componentId,
                componentInstanceId: elm.__overmind.componentInstanceId,
                name,
                flushId,
                paths: Array.from(tree.pathDependencies) as any,
              })
            }

            tree.track(onFlush)

            vnode = tag(propsObject, {
              state: tree.state,
              actions: _app.actions,
            })

            if (vnode.sel !== SELF) {
              throw new Error(
                `You are not returning a <self /> element from the component ${name} `
              )
            }

            vnode.data.hook = vnode.data.hook || {}
            const insert = vnode.data.hook.insert
            const update = vnode.data.hook.update
            const destroy = vnode.data.hook.destroy

            vnode.data.hook = {
              insert: (actualVnode) => {
                if (!(name in nextComponentId)) {
                  nextComponentId[name] = nextId++
                }
                if (!(name in nextComponentInstanceId)) {
                  nextComponentInstanceId[name] = 0
                }

                nextComponentInstanceId[name] = nextId++

                elm = actualVnode.elm
                vnode.elm = elm
                elm.__overmind = Object.assign(elm.__overmind || {}, {
                  name,
                  tree,
                  componentId: nextComponentId,
                  componentInstanceId: nextComponentInstanceId[name],
                })

                insert && insert(elm)

                _app.eventHub.emitAsync(EventType.COMPONENT_ADD, {
                  componentId: elm.__overmind.componentId,
                  componentInstanceId: elm.__overmind.componentInstanceId,
                  name,
                  paths: Array.from(tree.pathDependencies) as any,
                })
              },
              update: (_, vnode) => {
                elm = vnode.elm
                elm.__overmind.tree = tree
                update && update(vnode.elm)
              },
              destroy: (vnode) => {
                elm = vnode.elm
                tree.dispose()
                destroy && destroy(vnode.elm)
                _app.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
                  componentId: elm.__overmind.componentId,
                  componentInstanceId: elm.__overmind.componentInstanceId,
                  name,
                })
              },
            }

            tree.stopTracking()

            return vnode
          })
          .get(tag),
      memo
    )
  }

  return h(
    tag,
    normalizeAttrs(tag, attrs),
    children.reduce((aggr, item) => aggr.concat(item), [])
  )
}

export const render = (app, vnode, container) => {
  _app = app
  patch(container, vnode())
}
