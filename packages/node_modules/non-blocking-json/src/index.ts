// Symbol used as placeholders for objects and arrays
const IS_ARRAY_START = Symbol("IS_ARRAY_START");
const IS_ARRAY_END = Symbol("IS_ARRAY_END");
const IS_OBJECT_START = Symbol("IS_OBJECT_START");
const IS_OBJECT_END = Symbol("IS_OBJECT_END");

// This is how we batch up.
// STRINGIFY: The length of paths in the object
// PARSE: The length of the string
let BATCH_LENGTH = 3000
let TRACK_PERF = false;

export const tweak = (batchLength, trackPerf) => {
  BATCH_LENGTH = batchLength
  TRACK_PERF = Boolean(trackPerf);
};

const batch = (() => {
  let queue = []
  let isRunning = false
  async function run() {
    let tickLength = 0
    isRunning = true
    await Promise.resolve()
    while (queue.length && tickLength < BATCH_LENGTH) {
      const queueItem = queue.shift()
      queueItem.cb()
      tickLength += queueItem.length
    }

    if (queue.length) {
      run()
    } else {
      isRunning = false
    }
  }

  return (length, cb) => {
    queue.push({
      cb,
      length
    })
    

    if (!isRunning) {
      run()
    }    
  }
})()

/*
  This function takes a value which results in a Map of
  path to a value and placeholder IS_ARRAY/IS_OBJECT, or the static
  value. It takes a "replacer" function which allows you to intercept
  the created result
*/
function getPaths(value, paths, replacer, currentPath = [], index = { current: 0 }) {
  const replacedValue = replacer ? replacer(currentPath, value) : value;
  if (typeof replacedValue === "function" || typeof replacedValue === "symbol" || replacedValue === undefined) {
  } else if (Array.isArray(replacedValue)) {
    paths[index.current++] = [currentPath.slice(), IS_ARRAY_START]
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer ? replacer.bind(replacedValue) : replacer, currentPath, index);
      currentPath.pop();
    }
    paths[index.current++] = [currentPath.slice(), IS_ARRAY_END]
  } else if (replacedValue !== null && typeof replacedValue === "object") {
    paths[index.current++] = [currentPath.slice(), IS_OBJECT_START]
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer ? replacer.bind(replacedValue) : replacer, currentPath, index);
      currentPath.pop();
    }
    paths[index.current++] = [currentPath.slice(), IS_OBJECT_END]
  } else {
    paths[index.current++] = [currentPath.slice(), replacedValue]
  }

  return paths;
}

/*
  When parsing we replace all objects and arrays with a reference first,
  then we async resolve them. This function identifies a ref
*/
function isRef(ref) {
  if (typeof ref === "string" && ref.match(/\$\$REF_[0-9]/)) {
    return ref;
  }

  return null;
}

/*
  Divides the length into enumarable batches
*/
function getBatches(length: number) {
  return Array.from(new Array(Math.ceil(length / BATCH_LENGTH))).map((_, index) => Math.min(BATCH_LENGTH, length - (index * BATCH_LENGTH)))
}

/*
  This function takes value with an optional replacer. It will stringify
  the values async by first creating a MAP of all paths, as explained above.
  Then it iterates these paths and produces the JSON string
*/
export function stringify(value, replacer?) {
  return new Promise<string>(resolve => {
    const paths = getPaths(value, [], replacer ? replacer.bind(global || window) : replacer);
    const batches = getBatches(paths.length)
    const structs = [];
    let prevKey = [];
    let string = "";
    let start

    if (TRACK_PERF) {
      start = performance.now()
    }

    batches.forEach((length, index) => {
      batch(length, () => {
        const startIndex = index * BATCH_LENGTH
        
        for (let x = startIndex; x < startIndex + length; x++) {
          const [key, value] = paths[x]
          const currentKey = prevKey;
  
          prevKey = key;
  
          if (value === IS_OBJECT_END) {
            structs.pop()
            string += '}'
            continue
          }
          if (value === IS_ARRAY_END) {
            structs.pop()
            string += ']'
            continue
          }
  

  
          if (key.length && key.length <= currentKey.length) {
            string += ",";
          }
  
          let currentStruct = structs[structs.length - 1];
  
          if (value === IS_OBJECT_START) {
            structs.push(value);
            string += key.length && currentStruct === IS_OBJECT_START ? `"${key[key.length - 1]}":{` : "{";
            continue;
          }
  
          if (value === IS_ARRAY_START) {
            structs.push(value);
            string += key.length && currentStruct === IS_OBJECT_START ? `"${key[key.length - 1]}":[` : "[";
            continue;
          }
  
          currentStruct = structs[structs.length - 1];
          if (currentStruct === IS_OBJECT_START) {
            string += `"${key[key.length - 1]}":${JSON.stringify(value)}`;
            continue;
          }
          if (currentStruct === IS_ARRAY_START) {
            string += JSON.stringify(value);
            continue;
          }
        }
  
        if (index === batches.length - 1) {
          if (TRACK_PERF) {
            console.log("STRINGIFY TIME - ", performance.now() - start, paths.size)
          }
          resolve(string);
        }
      });
    })
  });
}

/*
  This function takes a JSON string and async parses it. It does this by looking
  tracking all "{", "[" and then when finding their end parts, "}" and "]", replaces
  the object/array with a reference. Each reference is then async parsed and 
  built back together
*/
export async function parse(value) {
  let refId = 0;
  const references = {};
  const openingObjectBrackets = [];
  const openingArrayBrackets = [];
  const initialLength = value.length

  let isInString = false;
  let start

  if (TRACK_PERF) {
    start = performance.now()
  }

  // Build references
  await new Promise((resolve) => {
    const batches = getBatches(value.length)
    batches.forEach((length, index) => {
      batch(length, () => {
        const startIndex = index * BATCH_LENGTH
        let endIndex = startIndex + length
        for (let charIndex = startIndex; charIndex < endIndex; charIndex++) {
            if (value[charIndex] === '"' && value[charIndex - 1] !== '\\') {
              isInString = !isInString;
              continue;
            }
        
            if (isInString) {
              continue;
            }
        
            if (value[charIndex] === "{") {
              openingObjectBrackets.push(charIndex);
            } else if (value[charIndex] === "[") {
              openingArrayBrackets.push(charIndex);
            } else if (value[charIndex] === "}") {
              const openingBracketIndex = openingObjectBrackets.pop();
              const id = `$$REF_${refId++}`;
              const ref = value.substr(
                openingBracketIndex,
                charIndex - openingBracketIndex + 1
              );
              references[id]  = ref
              value =
                value.substr(0, openingBracketIndex) +
                `"${id}"` +
                value.substr(charIndex + 1);
        
              charIndex = openingBracketIndex + id.length + 1;
              endIndex += id.length
              
            } else if (value[charIndex] === "]") {
              const openingBracketIndex = openingArrayBrackets.pop();
              const id = `$$REF_${refId++}`;
              references[id] = value.substr(
                openingBracketIndex,
                charIndex - openingBracketIndex + 1
              );
              value =
                value.substr(0, openingBracketIndex) +
                `"${id}"` +
                value.substr(charIndex + 1);
              charIndex = openingBracketIndex + id.length + 1;
              endIndex += id.length
            }
          }
        
    
       

        if (index === batches.length - 1) {
          resolve()
        } 
      })
      
    })    
  })

  return new Promise((resolve) => {
    
    function produceResult(currentValue) {
      const parsedValue = JSON.parse(currentValue);
      

      for (let key in parsedValue) {
        const nestedValue = parsedValue[key];

        if (isRef(nestedValue)) {
          parsedValue[key] = produceResult(references[nestedValue]);
        }
      }
      
      return parsedValue 
    }

    let initialValue = JSON.parse(value);

    if (isRef(initialValue)) {
      initialValue = references[initialValue];
    }

    // We batch the work by using the initial length of the value. This gives us an indication
    // of the number of objects and arrays that will need to be parsed
    batch(initialLength, () => {
      if (TRACK_PERF) {
        console.log("PARSE TIME - ", performance.now() - start)
      }
      resolve(produceResult(initialValue))
    })
    
  })
}
