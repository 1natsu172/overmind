// Symbol used as placeholders for objects and arrays
const IS_ARRAY_START = Symbol("IS_ARRAY_START");
const IS_ARRAY_END = Symbol("IS_ARRAY_END");
const IS_OBJECT_START = Symbol("IS_OBJECT_START");
const IS_OBJECT_END = Symbol("IS_OBJECT_END");

let ASYNC_BATCH_COUNT = 3000;
let TRACK_PERF = false;

export const tweak = (batchCount, trackPerf) => {
  ASYNC_BATCH_COUNT = batchCount;
  TRACK_PERF = Boolean(trackPerf);
};

const next = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;

/*
  This function takes a value which results in a Map of
  path to a value and placeholder IS_ARRAY/IS_OBJECT, or the static
  value. It takes a "replacer" function which allows you to intercept
  the created result
*/
function getPaths(value, paths, replacer, currentPath = []) {
  const replacedValue = replacer ? replacer(currentPath, value) : value;
  if (typeof replacedValue === "function" || typeof replacedValue === "symbol" || replacedValue === undefined) {
  } else if (Array.isArray(replacedValue)) {
    paths.set(currentPath.slice(), IS_ARRAY_START);
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer ? replacer.bind(replacedValue) : replacer, currentPath);
      currentPath.pop();
    }
    paths.set(currentPath.slice(), IS_ARRAY_END);
  } else if (replacedValue !== null && typeof replacedValue === "object") {
    paths.set(currentPath.slice(), IS_OBJECT_START);
    for (let key in replacedValue) {
      currentPath.push(key);
      getPaths(replacedValue[key], paths, replacer ? replacer.bind(replacedValue) : replacer, currentPath);
      currentPath.pop();
    }
    paths.set(currentPath.slice(), IS_OBJECT_END);
  } else {
    paths.set(currentPath.slice(), replacedValue);
  }

  return paths;
}

/*
  When parsing we replace all objects and arrays with a reference first,
  then we async resolve them. This function identifies a ref
*/
function isRef(ref) {
  if (typeof ref === "string" && ref.match(/\$\$REF_[0-9]/)) {
    return ref;
  }

  return null;
}

/*
  This function takes value with an optional replacer. It will stringify
  the values async by first creating a MAP of all paths, as explained above.
  Then it iterates these paths and produces the JSON string
*/
export function stringify(value, replacer?) {
  return new Promise<string>(resolve => {
    next(async () => {
      const paths = getPaths(value, new Map(), replacer ? replacer.bind(global || window) : replacer);
      const structs = [];
      let prevKey = [];
      let prevValue = null
      let string = "";
      let x = 0;
      let start

      if (TRACK_PERF) {
        start = performance.now()
      }

      for (let [key, value] of paths) {
        if (x % ASYNC_BATCH_COUNT === 0) {
          if (TRACK_PERF) {
            const end = performance.now()
            console.log("PERF - ", end - start)
            start = end
          }
          await new Promise(resolve => next(resolve));
        }

        x++;

        const currentKey = prevKey;

        prevKey = key;

        if (value === IS_OBJECT_END) {
          structs.pop()
          string += '}'
          continue
        }
        if (value === IS_ARRAY_END) {
          structs.pop()
          string += ']'
          continue
        }


        prevValue = value

        if (key.length && key.length <= currentKey.length) {
          string += ",";
        }

        let currentStruct = structs[structs.length - 1];

        if (value === IS_OBJECT_START) {
          structs.push(value);
          string += key.length && currentStruct === IS_OBJECT_START ? `"${key[key.length - 1]}":{` : "{";
          continue;
        }

        if (value === IS_ARRAY_START) {
          structs.push(value);
          string += key.length && currentStruct === IS_OBJECT_START ? `"${key[key.length - 1]}":[` : "[";
          continue;
        }

        currentStruct = structs[structs.length - 1];
        if (currentStruct === IS_OBJECT_START) {
          string += `"${key[key.length - 1]}":${JSON.stringify(value)}`;
          continue;
        }
        if (currentStruct === IS_ARRAY_START) {
          string += JSON.stringify(value);
          continue;
        }
      }

      resolve(string);
    });
  });
}

/*
  This function takes a JSON string and async parses it. It does this by looking
  tracking all "{", "[" and then when finding their end parts, "}" and "]", replaces
  the object/array with a reference. Each reference is then async parsed and 
  built back together
*/
export async function parse(value) {
  let refId = 0;
  const references = {};
  const openingObjectBrackets = [];
  const openingArrayBrackets = [];

  let isInString = false;
  let start

  if (TRACK_PERF) {
    start = performance.now()
  }

  for (let charIndex = 0; charIndex < value.length; charIndex++) {
    if (charIndex % ASYNC_BATCH_COUNT === 0) {
      if (TRACK_PERF) {
        const end = performance.now()
        console.log("PERF - ", end - start)
        start = end
      }
      await new Promise(resolve => next(resolve));
    }
    if (value[charIndex] === '"') {
      isInString = !isInString;
      continue;
    }

    if (isInString) {
      continue;
    }

    if (value[charIndex] === "{") {
      openingObjectBrackets.push(charIndex);
    } else if (value[charIndex] === "[") {
      openingArrayBrackets.push(charIndex);
    } else if (value[charIndex] === "}") {
      const openingBracketIndex = openingObjectBrackets.pop();
      const id = `$$REF_${refId++}`;
      references[id] = value.substr(
        openingBracketIndex,
        charIndex - openingBracketIndex + 1
      );
      value =
        value.substr(0, openingBracketIndex) +
        `"${id}"` +
        value.substr(charIndex + 1);

      charIndex = openingBracketIndex + id.length + 1;
    } else if (value[charIndex] === "]") {
      const openingBracketIndex = openingArrayBrackets.pop();
      const id = `$$REF_${refId++}`;
      references[id] = value.substr(
        openingBracketIndex,
        charIndex - openingBracketIndex + 1
      );
      value =
        value.substr(0, openingBracketIndex) +
        `"${id}"` +
        value.substr(charIndex + 1);
      charIndex = openingBracketIndex + id.length + 1;
    }
  }

  async function produceResult(value, i) {
    let parsedValue = JSON.parse(value);

    const keys = Object.keys(parsedValue);

    if (i % ASYNC_BATCH_COUNT === 0) {
      await new Promise(resolve => next(resolve));
    }

    return Promise.all(
      keys.map(async (key, index) => {
        const value = parsedValue[key];
        i++;
        if (isRef(value)) {
          parsedValue[key] = await produceResult(references[value], i + index);
        }
      })
    ).then(() => parsedValue);
  }

  let initialValue = JSON.parse(value);
  if (isRef(initialValue)) {
    initialValue = references[initialValue];
  }

  return produceResult(initialValue, 0);
}
