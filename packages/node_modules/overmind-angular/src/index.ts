// @ts-ignore
import { Injectable } from '@angular/core'
import { Overmind, EventType } from 'overmind'
import { BehaviorSubject, Observable } from 'rxjs'
import { map } from 'rxjs/operators'

const IS_PRODUCTION = process.env.NODE_ENV === 'production'

let nextComponentId = 0

export const Track = (Component) => {
  if (IS_PRODUCTION) {
    return
  }

  const componentId = nextComponentId++
  let componentInstanceId = 0

  function findService(target) {
    return Object.keys(target).find((key) => target[key] instanceof Service)
  }

  const targetNgOnInit = Component.prototype.ngOnInit
  Component.prototype.ngOnInit = function() {
    const service = this[findService(this)]
    service.addComponent({
      componentId,
      componentInstanceId: componentInstanceId++,
      name: Component.name,
    })

    targetNgOnInit && targetNgOnInit.call(this)
  }
}

@Injectable()
export class Service<App extends Overmind<any>> {
  private tree: any
  private state$: Observable<any>
  private subject: BehaviorSubject<any>
  private overmind: App
  private componentDetails: any
  actions: App['actions']
  effects: App['effects']
  addMutationListener: App['addMutationListener']
  constructor(overmind: App) {
    this.tree = (overmind as any).proxyStateTree.getTrackStateTreeWithProxifier()
    this.subject = new BehaviorSubject(this.tree.state)
    this.state$ = this.subject.asObservable()
    this.overmind = overmind

    this.actions = this.overmind.actions
    this.addMutationListener = this.overmind.addMutationListener

    this.tree.track(this.onUpdate)
  }
  private addComponent(componentDetails) {
    this.componentDetails = componentDetails
    this.overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
      componentId: componentDetails.componentId,
      componentInstanceId: componentDetails.componentInstanceId,
      name: componentDetails.name,
      paths: Array.from(this.tree.pathDependencies) as any,
    })
  }
  private onUpdate = (mutations, paths, flushId) => {
    this.tree.track(this.onUpdate)
    this.subject.next(this.tree.state)
    if (this.componentDetails) {
      this.overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
        componentId: this.componentDetails.componentId,
        componentInstanceId: this.componentDetails.componentInstanceId,
        name: this.componentDetails.name,
        paths: Array.from(this.tree.pathDependencies) as any,
        flushId,
      })
    }
  }
  private ngOnDestroy() {
    ;(this.overmind as any).proxyStateTree.disposeTree(this.tree)
    if (this.componentDetails) {
      this.overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
        componentId: this.componentDetails.componentId,
        componentInstanceId: this.componentDetails.componentInstanceId,
        name: this.componentDetails.name,
      })
    }
  }
  select<T>(expr: (state: App['state']) => T): Observable<T>
  select(): Observable<App['state']> {
    return this.state$.pipe(
      map((value) => (arguments[0] ? arguments[0](value) : value))
    )
  }
}
