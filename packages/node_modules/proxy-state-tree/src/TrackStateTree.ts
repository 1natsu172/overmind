import {
  IProxyStateTree,
  ITrackStateTree,
  ITrackCallback,
  IProxifier,
  ITrackScopedCallback,
} from './types'

export class TrackStateTree<T extends object> implements ITrackStateTree<T> {
  master: IProxyStateTree<T>
  pathDependencies: Set<string> = new Set()
  callback: ITrackCallback
  shouldTrack: boolean = false
  state: T
  proxifier: IProxifier<T>
  constructor(master: IProxyStateTree<T>) {
    this.master = master
    this.proxifier = master.proxifier
    this.state = master.state
  }
  canMutate() {
    return false
  }
  canTrack() {
    return true
  }
  addTrackingPath(path: string) {
    if (!this.shouldTrack) {
      return
    }

    this.pathDependencies.add(path)

    if (this.callback) {
      this.master.addPathDependency(path, this.callback)
    }
  }
  track(cb?: ITrackCallback) {
    this.master.changeTrackStateTree(this)
    this.shouldTrack = true
    if (this.callback) {
      for (let path of this.pathDependencies) {
        this.master.removePathDependency(path, this.callback)
      }
    }

    this.pathDependencies.clear()

    if (cb) {
      this.callback = (...args) => {
        if (!this.callback) {
          return
        }
        cb(...args)
      }
    }

    return this
  }
  stopTracking() {
    this.shouldTrack = false
  }
  trackScope(scope: ITrackScopedCallback<T>, cb?: ITrackCallback) {
    const previousPreviousTree = this.master.previousTree
    const previousCurrentTree = this.master.currentTree
    this.master.currentTree = this
    this.track(cb)
    const result = scope(this)
    this.master.currentTree = previousCurrentTree
    this.master.previousTree = previousPreviousTree
    this.stopTracking()
    return result
  }
  dispose() {
    if (!this.callback) {
      this.pathDependencies.clear()

      return this
    }

    for (let path of this.pathDependencies) {
      this.master.removePathDependency(path, this.callback)
    }

    this.pathDependencies.clear()
    this.callback = null
    this.proxifier = this.master.proxifier

    if (this.master.currentTree === this) {
      this.master.currentTree = null
    }

    return this
  }
}
