import { AppMessage, AppMessageType } from './overmind/types'

type Message = {
  appName: string
  messages: AppMessage<any>[]
}

type MessageCallback = (message: Message) => void

class WebsocketConnector {
  private nextEvaluationId = 0
  private callbacks: {
    [event: string]: Function[]
  } = {}
  private socket = new WebSocket('ws://localhost:1040')
  private messagesBeforeConnected: Array<[string, any, any]> = []
  private isOpen = false
  constructor() {
    this.socket.onmessage = (message) => {
      const parsedMessage = JSON.parse(message.data)

      if (this.callbacks[parsedMessage.type]) {
        this.callbacks[parsedMessage.type].forEach((cb) =>
          cb(parsedMessage.data)
        )
      }
    }
    this.socket.onopen = () => {
      this.isOpen = true
      this.messagesBeforeConnected.forEach((message) => {
        this.send(...message)
      })
      this.messagesBeforeConnected.length = 0
    }
  }
  on(event: string, cb: Function) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = []
    }

    this.callbacks[event].push(cb)
  }
  off(event, cb) {
    if (this.callbacks[event]) {
      this.callbacks[event].splice(this.callbacks[event].indexOf(cb), 1)
    }
  }
  send(event: string, data?: any, onEvaluated?: Function) {
    if (!this.isOpen) {
      this.messagesBeforeConnected.push([event, data, onEvaluated])
      return
    }
    const nextEvaluationId = this.nextEvaluationId++

    this.socket.send(
      JSON.stringify({
        type: event,
        data,
        evaluate: onEvaluated ? nextEvaluationId : undefined,
      })
    )

    if (onEvaluated) {
      const cb = (data) => {
        if (data.id === nextEvaluationId) {
          this.off('evaluated', cb)
          onEvaluated(data.error ? data.error : null, data.data)
        }
      }
      this.on('evaluated', cb)
    }
  }
}

export class BackendConnector extends WebsocketConnector {
  port: string
  messageCallback: MessageCallback
  constructor() {
    super()
    this.on('port:exists', this.onPortExists)
  }
  connect(port: string) {
    this.send('connect', port)
  }
  onMessage = (onMessage: MessageCallback) => {
    this.messageCallback = onMessage
    this.on('message', (message) => onMessage(message))
  }
  onPortExists = (_) => {
    this.messageCallback({
      appName: null,
      messages: [
        {
          appName: '',
          type: AppMessageType.PORT_EXISTS,
          data: null,
        },
      ],
    })
  }
  sendMessage(appName: string, eventName: string, payload: object = null) {
    this.send('message', {
      appName,
      type: eventName,
      data: payload,
    })
  }
  relaunch() {
    this.send('relaunch')
  }
}

export default BackendConnector
